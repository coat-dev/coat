import fs from "fs-extra";
import path from "path";
import { testExceptWindows } from "../utils/test-except-windows";
import { prepareCliTest, runSyncTest } from "../utils/run-cli-test";
import { runCli } from "../utils/run-cli";
import { CoatManifestFileType } from "../../src/types/coat-manifest-file";
import { COAT_MANIFEST_FILENAME } from "../../src/constants";
import { getFileHash } from "../../src/util/get-file-hash";
import stripAnsi from "strip-ansi";

describe("coat sync - delete unmanaged files", () => {
  describe("global files", () => {
    test("should delete files that are no longer generated by coat", async () => {
      const unmanagedFilePath = "file.json";

      const cwd = await prepareCliTest({
        coatGlobalLockfile: {
          version: 1,
          files: [
            {
              path: `folder-1/${unmanagedFilePath}`,
              hash: getFileHash(""),
            },
          ],
        },
      });

      // Place unmanaged file
      await fs.outputFile(path.join(cwd, "folder-1", unmanagedFilePath), "");

      const { task } = runCli(["sync"], { cwd });
      const result = await task;
      expect(stripAnsi(result.stdout)).toMatchInlineSnapshot(`
        "
          CREATED  .gitignore
          DELETED  folder-1/file.json
          UPDATED  package.json
        "
      `);

      await expect(
        fs.readFile(path.join(cwd, "folder-1", unmanagedFilePath))
      ).rejects.toHaveProperty(
        "message",
        expect.stringMatching(
          /ENOENT: no such file or directory, open '.*file.json'$/
        )
      );
    });

    test("should not throw any error if unmanaged files don't exist anymore", async () => {
      const unmanagedFilePath = "file.json";

      const { task } = await runSyncTest({
        coatGlobalLockfile: {
          version: 1,
          files: [
            {
              path: unmanagedFilePath,
              hash: getFileHash(""),
            },
          ],
        },
      });

      const result = await task;
      expect(stripAnsi(result.stdout)).toMatchInlineSnapshot(`
        "
          CREATED  .gitignore
          UPDATED  package.json
        "
      `);
    });

    testExceptWindows(
      "should throw errors if unmanaged files cannot be accessed",
      async () => {
        const unmanagedFileName = "file.json";

        const cwd = await prepareCliTest({
          coatGlobalLockfile: {
            version: 1,
            files: [
              {
                path: `folder-1/${unmanagedFileName}`,
                hash: getFileHash(""),
              },
            ],
          },
        });

        // Place unmanaged file
        await fs.outputFile(path.join(cwd, "folder-1", unmanagedFileName), "");
        // Deny access to unmanaged file
        await fs.chmod(path.join(cwd, "folder-1"), 0o000);

        try {
          const { task } = runCli(["sync"], { cwd });
          await expect(task).rejects.toHaveProperty(
            "message",
            expect.stringMatching(
              /.*EACCES: permission denied, open '.*file.json'/
            )
          );
        } finally {
          await fs.chmod(path.join(cwd, "folder-1"), 0o777);
        }
      }
    );

    test("should not delete files that are only placed once", async () => {
      const { cwd, task: firstSyncRun } = await runSyncTest({
        coatManifest: {
          name: "test",
          files: [
            {
              file: "file.json",
              content: { a: true },
              type: CoatManifestFileType.Json,
              once: true,
            },
          ],
        },
      });
      const firstSyncResult = await firstSyncRun;
      expect(stripAnsi(firstSyncResult.stdout)).toMatchInlineSnapshot(`
        "
          CREATED  .gitignore
          CREATED  file.json
          UPDATED  package.json
        "
      `);

      let fileRaw = await fs.readFile(path.join(cwd, "file.json"), "utf-8");
      expect(JSON.parse(fileRaw)).toEqual({ a: true });

      // Adjust coat manifest to no longer place file
      await fs.writeFile(
        path.join(cwd, COAT_MANIFEST_FILENAME),
        JSON.stringify({ name: "test" })
      );

      // Run sync again
      const { task: secondSyncRun } = runCli(["sync"], { cwd });
      const secondSyncResult = await secondSyncRun;
      expect(stripAnsi(secondSyncResult.stdout)).toMatchInlineSnapshot(`
        "
        ♻️ Everything up to date
        "
      `);

      fileRaw = await fs.readFile(path.join(cwd, "file.json"), "utf-8");
      expect(JSON.parse(fileRaw)).toEqual({ a: true });
    });
  });

  describe("local files", () => {
    test("should delete files that are no longer generated by coat", async () => {
      const unmanagedFilePath = "file.json";

      const cwd = await prepareCliTest({
        coatLocalLockfile: {
          version: 1,
          files: [
            {
              path: `folder-1/${unmanagedFilePath}`,
              hash: getFileHash(""),
            },
          ],
        },
      });

      // Place unmanaged file
      await fs.outputFile(path.join(cwd, "folder-1", unmanagedFilePath), "");

      const { task } = runCli(["sync"], { cwd });
      const result = await task;
      expect(stripAnsi(result.stdout)).toMatchInlineSnapshot(`
        "
          CREATED  .gitignore
          DELETED  folder-1/file.json
          UPDATED  package.json
        "
      `);

      await expect(
        fs.readFile(path.join(cwd, "folder-1", unmanagedFilePath))
      ).rejects.toHaveProperty(
        "message",
        expect.stringMatching(
          /ENOENT: no such file or directory, open '.*file.json'$/
        )
      );
    });

    test("should not throw any error if unmanaged files don't exist anymore", async () => {
      const unmanagedFilePath = "file.json";

      const { task } = await runSyncTest({
        coatLocalLockfile: {
          version: 1,
          files: [
            {
              path: unmanagedFilePath,
              hash: "",
            },
          ],
        },
      });

      const result = await task;
      expect(stripAnsi(result.stdout)).toMatchInlineSnapshot(`
        "
          CREATED  .gitignore
          UPDATED  package.json
        "
      `);
    });

    testExceptWindows(
      "should throw errors if unmanaged files cannot be accessed",
      async () => {
        const unmanagedFileName = "file.json";

        const cwd = await prepareCliTest({
          coatLocalLockfile: {
            version: 1,
            files: [
              {
                path: `folder-1/${unmanagedFileName}`,
                hash: getFileHash(""),
              },
            ],
          },
        });

        // Place unmanaged file
        await fs.outputFile(path.join(cwd, "folder-1", unmanagedFileName), "");
        // Deny access to unmanaged file
        await fs.chmod(path.join(cwd, "folder-1"), 0o000);

        try {
          const { task } = runCli(["sync"], { cwd });
          await expect(task).rejects.toHaveProperty(
            "message",
            expect.stringMatching(
              /.*EACCES: permission denied, open '.*file.json'/
            )
          );
        } finally {
          await fs.chmod(path.join(cwd, "folder-1"), 0o777);
        }
      }
    );

    test("should not delete files that are only placed once", async () => {
      const { cwd, task: firstSyncRun } = await runSyncTest({
        coatManifest: {
          name: "test",
          files: [
            {
              file: "file.json",
              content: { a: true },
              type: CoatManifestFileType.Json,
              once: true,
              local: true,
            },
          ],
        },
      });
      const firstSyncResult = await firstSyncRun;
      expect(stripAnsi(firstSyncResult.stdout)).toMatchInlineSnapshot(`
        "
          CREATED  .gitignore
          CREATED  file.json
          UPDATED  package.json
        "
      `);

      let fileRaw = await fs.readFile(path.join(cwd, "file.json"), "utf-8");
      expect(JSON.parse(fileRaw)).toEqual({ a: true });

      // Adjust coat manifest to no longer place file
      await fs.writeFile(
        path.join(cwd, COAT_MANIFEST_FILENAME),
        JSON.stringify({ name: "test" })
      );

      // Run sync again
      const { task: secondSyncRun } = runCli(["sync"], { cwd });
      const secondSyncResult = await secondSyncRun;
      expect(stripAnsi(secondSyncResult.stdout)).toMatchInlineSnapshot(`
        "
        ♻️ Everything up to date
        "
      `);

      fileRaw = await fs.readFile(path.join(cwd, "file.json"), "utf-8");
      expect(JSON.parse(fileRaw)).toEqual({ a: true });
    });

    test("should delete managed files if they are no longer declared", async () => {
      const { cwd, task: firstSyncRun } = await runSyncTest({
        coatManifest: {
          name: "test",
          files: [
            {
              file: "file.json",
              content: { a: true },
              type: CoatManifestFileType.Json,
              once: false,
              local: true,
            },
          ],
        },
      });
      const firstSyncResult = await firstSyncRun;
      expect(stripAnsi(firstSyncResult.stdout)).toMatchInlineSnapshot(`
        "
          CREATED  .gitignore
          CREATED  file.json
          UPDATED  package.json
        "
      `);

      const fileRaw = await fs.readFile(path.join(cwd, "file.json"), "utf-8");
      expect(JSON.parse(fileRaw)).toEqual({ a: true });

      // Adjust coat manifest to no longer place file
      await fs.writeFile(
        path.join(cwd, COAT_MANIFEST_FILENAME),
        JSON.stringify({ name: "test" })
      );

      // Run sync again
      const { task: secondSyncRun } = runCli(["sync"], { cwd });
      const secondSyncResult = await secondSyncRun;
      expect(stripAnsi(secondSyncResult.stdout)).toMatchInlineSnapshot(`
        "
          DELETED  file.json
        "
      `);

      await expect(
        fs.readFile(path.join(cwd, "file.json"))
      ).rejects.toHaveProperty(
        "message",
        expect.stringMatching(
          /ENOENT: no such file or directory, open '.*file.json'$/
        )
      );
    });
  });
});
