import { JsonObject, ValueOf } from "type-fest";

export enum CoatManifestFileType {
  Json = "JSON",
  Text = "TEXT",
  Yaml = "YAML",
}

export interface CoatManifestFileContentTypesMap {
  [CoatManifestFileType.Json]: JsonObject;
  [CoatManifestFileType.Text]: string;
  [CoatManifestFileType.Yaml]: JsonObject;
}

export type CoatManifestFileContentType = ValueOf<CoatManifestFileContentTypesMap>;

export interface CoatManifestFileBase<FileType extends CoatManifestFileType> {
  /**
   * The relative path to the file from the coat project root,
   * e.g. file.json -> project-dir/file.json
   */
  file: string;
  /**
   * The type of the file, e.g. "JSON" or "TEXT"
   *
   * Used to determine the type of the content
   */
  type: FileType;
  /**
   * The content of the file
   *
   * Examples:
   * { a: true, b: { c: true } } for "JSON" or "YAML"
   * "Hello world" for "TEXT"
   *
   * If the content is null, the file will not be placed on the file system.
   * This behavior can be used to prevent extended templates from placing
   * undesired files.
   *
   * The content property can also be a function that receives a previous
   * value that can modified or merged into a new result value. This function
   * can also be asynchronous and returning null will prevent the file from
   * being placed.
   */
  content:
    | CoatManifestFileContentTypesMap[FileType]
    | ((
        /**
         * Previous content of the file that has been provided by
         * an earlier CoatManifestFile entry.
         *
         * This content should be used as a base for merging
         * (if merging is the desired outcome)
         */
        previous: CoatManifestFileContentTypesMap[FileType] | undefined | null,
        /**
         * The default merge function used by coat. Useful when you
         * want to perform certain operations based on the previous content
         * and want to use the same merge mechanism that is provided by coat.
         */
        merge: (
          source: CoatManifestFileContentTypesMap[FileType] | undefined | null,
          target: CoatManifestFileContentTypesMap[FileType]
        ) => CoatManifestFileContentTypesMap[FileType] | null
      ) =>
        | null
        | CoatManifestFileContentTypesMap[FileType]
        | Promise<null | CoatManifestFileContentTypesMap[FileType]>)
    | null;
  /**
   * Whether a file should only be generated once or continously be generated by coat.
   *
   * Setting once to true should be used for starting files in a project, e.g.
   * to place the first version of an "index.js" file for a new JavaScript package
   */
  once?: boolean;
  /**
   * Whether a file is only generated locally and not a part of the repository that
   * is tracked in git.
   *
   * Setting local to true should be used for developer specific files, like editor
   * configuration files or environment variable tooling.
   */
  local?: boolean;
}

type UnionizeFileTypes<FileType> = FileType extends CoatManifestFileType
  ? CoatManifestFileBase<FileType>
  : never;

export type CoatManifestFile = UnionizeFileTypes<CoatManifestFileType>;
export type CoatManifestGroupedFile = Omit<CoatManifestFile, "content"> & {
  content: CoatManifestFile["content"][];
  relativePath: string;
  once: boolean;
  local: boolean;
};

export type CoatManifestMergedFile = Omit<
  CoatManifestGroupedFile,
  "content"
> & {
  content: CoatManifestFileContentType;
};
