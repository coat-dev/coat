# ðŸ“š coat documentation

## Table of contents

TODO

## How coat works

## Examples

You can find examples of coat projects and coat templates in the [examples folder](../examples/README.md).

## Customization

Files that are continuously managed by coat can be customized by placing a `<filename>-custom.js` file next to them.

Depending on the file type, the customization file either directly exports a value that will be merged into the file that is generated by coat or a function that receives the generated value and coat's own merge function for easier access.

Exporting `null` or returning `null` from the exported merge function will stop coat from placing the file on the disk.

### Example

Let's assume a coat project generates a `JSON` file named `config.json`:

`// config.json`
```js
{
  "coatValue": "generated value",
  "coatArray": ["generated array entry"]
}
```

We can now customize this file by placing a `config.json-custom.js` file next to our `config.json` file:

`// config.json-custom.js`
```js
module.exports = {
  "coatArray": ["custom array entry"],
  "customValue": "custom value",
}
```

After running `coat sync` again, the contents of `config.json` are updated:

`// config.json`
```js
{
  "coatValue": "generated value",
  "coatArray": ["custom array entry"], // Replaced from our customization file
  "customValue": "custom value"
}
```

We can also export a function, to specify our own merge behavior:

`// config.json-custom.js`
```js
module.exports = (oldConfig, mergeFunction) => {
  const newConfig = {
    coatArray: ["custom array entry", ...oldConfig.coatArray],
    customValue: "custom value",
  }

  return mergeFunction(oldConfig, newConfig);
}
```
`// config.json`
```js
{
  "coatValue": "generated value",
  "coatArray": ["custom array entry", "generated array entry"],
  "customValue": "custom value"
}
```

The type of the exported or returned value have to correspond to the file type of the generated file. Let's look at an example of a `TEXT` file that expects a `string` instead of an `object`:

`// .gitignore (before customization)`
```
node_modules
/build
```

`// .gitignore-custom.js`
```js
module.exports = `
node_modules
/build

custom_ignore_entry.txt
`
```

`// .gitignore (result)`
```
node_modules
/build

custom_ignore_entry.txt
```

### File Types

#### JSON

Expected return value: **JSON object**

Default merge behavior: Properties are deeply merged, arrays are replaced.

#### TEXT

Expected return value: **string**

Default merge behavior: The old string value is fully replaced.

#### YAML

Expected return value: **JSON object**

Default merge behavior: Properties are deeply merged, arrays are replaced.

### Why can't I edit files directly and merge them in-place?

Some files could be easily edited and merged in place. For example, adding a deep property to a JSON object or adding a line to a .gitignore file might make it easier to work inside a coat project.

While this would be technically possible - and is even supported for the package.json file - it creates a larger problem: A **UX issue** on how to use coat easily and correctly.

`coat` projects follow a simple data flow: Templates should provide a full and working configuration and `coat` allows the user of these templates to customize them to their intended use case. If in-place editing would be permitted by coat, it would no longer be clear on why certain customizations can be performed in-place, while others can't be performed. When adding a JSON property, `coat` would leave the property alone as long as the template does not specify a different value for this property. When the template is updated, the previously applied customization would then be overwritten, which would not happen if the customization is merged and applied last.

This issue also holds true for simpler use cases, e.g. when working with a `.gitignore` file. Let's assume that a coat template wants to leave `node_modules` - a folder that is typically ignored for most JavaScript projects - tracked by git for auditing, security or any other reason*. When adding `node_modules` to .gitignore to directly, the template can decide to wipe this line from the resulting .gitignore, which might then leave the user of this coat template to wonder why they can't add `node_modules` to the `.gitignore` file, although their addition of e.g. `log-file.*` worked out fine.

The existence of a `.gitignore-custom.js` file - that is applied and merged last by coat - ensures that the customizations of a user are applied and merged **last**, leaving the user in full control of the desired file content.

`*` - Note: I do not recommend to check in `node_modules` in JavaScript projects. I've simply seen teams do it - and if it works for them they should be able to do so.

#### Exceptions to the rule

As mentioned above, the `package.json` file in coat projects is merged in-place. The rationale behind this is that it is a file that is often **modified by tooling** in addition to being edited by users directly. In this particular example, users often add or remove dependencies by calling `npm install X`. Forcing the user to find out the latest version of a dependency and adding it to a customization file would be too much to ask and decrease developer productivity - which `coat` aims to increase as a goal.

It is planned (TODO: Add link to issue) to allow to specify a property for these types of files, which would signalize coat that it does not need to check the file content for modifications and warn the user when the contents mismatch from a previous run of `coat sync`.

Please note however that even in these cases **direct modifications of these files by the user are discouraged** and should still be applied via a customization file, in order to not run into any issues where a property that should be set is also applied by a template.

It is possible to add an existing file to template's files by specifying it early in the `files` property of a `coat` template:

TODO: Try out template below!

`// coat-template.ts`
```ts
import { promises as fs } from "fs";
import path from "path";
import { CoatTemplate } from "@coat/cli";

const templateFunction: CoatTemplate = ({ coatContext }) => {
  return {
    name: "my-template",
    files: [{
      file: "config.json",
      type: "JSON",
      content: async () => {
        try {
          // Try to read the existing file
          // from the project directory
          const existingConfigRaw = await fs.readFile(
            path.join(coatContext.cwd, "config.json"),
            "utf-8"
          );
          // Parse the config, since a JSON content function must
          // return a JSON object
          const existingConfig = JSON.parse(existingConfigRaw);
          return existingConfig;
        } catch (error) {
          if (error.code !== "ENOENT") {
            throw error;
          }
          // The file does not exist (yet) on the disk,
          // return a default value or null depending on your
          // use case.
          return {};
        }
      }
    }]
  };
}

export default templateFunction;
```

**Note:** Until TODO! is implemented, `coat sync` will prompt before updating the file each time the content of the file has changed, since user modifications are disallowed by default and coat tries to prevent accidental file loss.

## CLI commands

### `sync`

Usage: `coat sync`

Runs all necessary setup tasks and generates all files of a coat project. Must be run inside a coat project folder that contains a coat manifest file (coat.json).

Arguments: None

Options: None

### `create`

**Usage:** `coat create <template> [dir] [projectName]`

Creates a new project based on the coat template.

Arguments:

| Argument      | Type                  | Default                                                                                  | Description                                                                                                                                        |
|---------------|-----------------------|------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| **`template`**    | **string (Required)** | /                                                                                        | The name of coat template from the npm registry (e.g. `@coat/template-ts-package`)                                                                 |
| `dir`         | string                | By default a new folder will be created based on the project name that will be prompted. | The directory where coat should create a project. Resolves to a relative path from the current working directory, but absolute paths work as well. |
| `projectName` | string                | Uses the `dir` argument, if it is not a complex path expression.                         | The name of your new project.                                                                                                                      |

Options: None

### `run`

Usage: `coat run <scriptPattern> [otherScriptPatterns...]`

Runs one or multiple package.json scripts in parallel. You can run multiple scripts by specifying a wildcard, e.g. coat run build:* will run all scripts that are prefixed with build: inside the package.json scripts object. All arguments after the first dash ("-") will be passed to each script, e.g. `coat run build --watch` will call the build script with `--watch`

If a script name or pattern do not conflict with a built-in coat cli command, you can also omit the "run" command to execute the script or pattern:

```sh
coat run build
# or without run
coat build
```

Arguments: None

Options: None

### `setup`

Usage: `coat setup`

Sequentially runs all setup tasks of the current coat project, even if they have already been run previously. Must be run inside a coat project folder that contains a coat manifest file (coat.json).

Arguments: None

Options: None

## Template reference

The following sections explain the properties that a coat template can specify. A template can have the following property types:

```ts
interface CoatManifest {
  name: string;
  extends?: string | (string | [string, Record<string, unknown>])[];
  // See `files` below for more detail
  files?: CoatManifestFile[]
  // See `setup` below for more detail
  setup?: CoatManifestTask[]
  // See `scripts` below for more detail
  scripts?: CoatManifestScript[]
  dependencies?: {
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
    optionalDependencies?: Record<string, string>;
  }
}
```

### `name`

The name of the coat template or project. Useful for debugging purposes to show the origin in case an error occurs.

### `extends`

The coat template or templates that are extended by a template or project. The string expression is passed to node's require function, therefore local files that export a template can be referenced as well. Examples:

```ts
const template = {
  // ...
  // Extends the @coat/template-ts-package template from node_modules
  extends: "@coat/template-ts-package",
  //
  // Extends @coat/template-ts-package from "node_modules" and a local
  // template in the ./templates folder relative from the project directory
  extends: [
    "@coat/template-ts-package",
    "./templates/my-template.js"
  ]
}
```

Templates can accept a configuration object which is passed to the template in a tuple:

```ts
const template = {
  // ...
  // Config example
  extends: [
    ["@coat/template-ts-package", { "compiler": "babel" }]
  ]
}
```

### `files`

Generated files are the heart of a coat project. An entry in the `files` array can have the following properties:

#### `file`

**Required**

Type: `string`

The *relative* path of the generated file from the coat project directory.

Examples:
```ts
const template = {
  files: [{
    // Example #1
    file: "config.json" // placed next to coat.json
    // Example #2
    file: "sub-folder-1/sub-folder-2/config.json" // Placed inside two sub-folders relative to the directory that houses coat.json
    //
    // ... other file properties ...
  }]
}
```

Restrictions:

* The file path must not be absolute.
* The file path must not lead to a parent folder outside of the coat project directory.

#### `type`

**Required**

Type: One of `JSON` | `YAML` | `TEXT`

The type of the file which determines the type of the `content` property and how the file will be merged. `@coat/cli` exports the `CoatManifestFileType` enum, which holds the types as accessible constants. `TEXT` is the most generic file type and can be used for all files or use cases where a more specific file type is unavailable (like gradle build configurations, Podfile specifications, etc.).

Examples:
```ts
import { CoatManifestFileType } from "@coat/cli";

const template = {
  files: [{
    // Example #1
    file: "config.json",
    type: "JSON", // or CoatManifestFileType.Json
    // ...
    // Example #2
    file: ".gitignore",
    type: CoatManifestFileType.Text // or "TEXT"
    // ... other file properties ...
  }]
}
```

Restrictions:

* If there are multiple entries of a file in a coat projects (by multiple templates specifying file entries with the same `file` path property), they must have the same `type` property.

#### `content`

**Required**

Type: Depends on `file.type`:

`type` | `content` type | Comment
----------- | -------------- | -------
`JSON` | `JsonObject` | A JavaScript object without any non-serializable properties (e.g. Functions)
`YAML` | `JsonObject` | Same as for `JSON`
`TEXT` | `string` | The string content (including new lines) of the resulting file.

Examples:

```ts
import { CoatManifestFileType } from "@coat/cli";

const template = {
  files: [{
    // Example 1
    file: "config.json",
    type: CoatManifestFileType.Json,
    content: {
      myConfigProperty: "myConfigValue",
      deepConfigProperty: {
        deepProp: ["value"]
      }
    }
    // ...
    // Example 2
    file: ".gitignore",
    type: CoatManifestFileType.Text,
    // Ignores node_modules and build folders
    content: "node_modules\nbuild"
    // ...
  }]
}
```

TODO: Continue here
TODO: Function explanation as well

#### File types

TODO

### `setup`

TODO

### `scripts`

TODO

### `dependencies`

TODO
